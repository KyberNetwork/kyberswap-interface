---
description: Web3 and blockchain development patterns
globs:
  [
    "**/hooks/use*Contract*",
    "**/hooks/use*Transaction*",
    "**/services/**",
    "**/utils/web3*",
  ]
alwaysApply: false
---

# Web3 Development Rules

## Wallet Connection

Use wagmi hooks for wallet interactions:

```typescript
import { useAccount, useConnect, useDisconnect } from 'wagmi'

function WalletButton() {
  const { address, isConnected } = useAccount()
  const { connect, connectors } = useConnect()
  const { disconnect } = useDisconnect()

  if (isConnected) {
    return <button onClick={() => disconnect()}>{address}</button>
  }

  return (
    <>
      {connectors.map((connector) => (
        <button key={connector.id} onClick={() => connect({ connector })}>
          {connector.name}
        </button>
      ))}
    </>
  )
}
```

## Contract Reads

```typescript
import { useReadContract } from 'wagmi'
import { erc20Abi } from 'viem'

function TokenBalance({ token, account }: Props) {
  const { data: balance } = useReadContract({
    address: token,
    abi: erc20Abi,
    functionName: 'balanceOf',
    args: [account],
  })

  return <span>{balance?.toString()}</span>
}
```

## Contract Writes

```typescript
import { useWriteContract, useWaitForTransactionReceipt } from 'wagmi'

function ApproveButton({ token, spender, amount }: Props) {
  const { writeContract, data: hash } = useWriteContract()
  const { isLoading, isSuccess } = useWaitForTransactionReceipt({ hash })

  const handleApprove = () => {
    writeContract({
      address: token,
      abi: erc20Abi,
      functionName: 'approve',
      args: [spender, amount],
    })
  }

  return (
    <button onClick={handleApprove} disabled={isLoading}>
      {isLoading ? 'Confirming...' : 'Approve'}
    </button>
  )
}
```

## Chain Handling

```typescript
import { useChainId, useSwitchChain } from 'wagmi'

function ChainSelector() {
  const chainId = useChainId()
  const { switchChain, chains } = useSwitchChain()

  return (
    <select
      value={chainId}
      onChange={(e) => switchChain({ chainId: Number(e.target.value) })}
    >
      {chains.map((chain) => (
        <option key={chain.id} value={chain.id}>
          {chain.name}
        </option>
      ))}
    </select>
  )
}
```

## BigInt Handling

- Always use `BigInt` for token amounts (never `number`)
- Use viem utilities for formatting/parsing

```typescript
import { formatUnits, parseUnits } from "viem";

// Parse user input to BigInt
const amount = parseUnits(inputValue, decimals);

// Format BigInt for display
const display = formatUnits(balance, decimals);
```

## Error Handling

```typescript
import { useWriteContract } from "wagmi";
import { toast } from "react-hot-toast";

function SwapButton() {
  const { writeContract } = useWriteContract();

  const handleSwap = async () => {
    try {
      await writeContract({
        // ...
      });
    } catch (error) {
      if (error.code === 4001) {
        toast.error("Transaction rejected by user");
      } else if (error.code === -32603) {
        toast.error("Transaction failed - check gas and balance");
      } else {
        toast.error("Transaction failed");
        console.error(error);
      }
    }
  };
}
```

## Address Validation

```typescript
import { isAddress, getAddress } from "viem";

// Validate address
if (!isAddress(input)) {
  throw new Error("Invalid address");
}

// Checksum address
const checksummed = getAddress(input);
```

## Common Pitfalls

### ❌ Don't

- Use `number` for token amounts (precision loss)
- Hardcode chain IDs (use constants)
- Forget to handle transaction rejections
- Ignore gas estimation failures

### ✅ Do

- Use `BigInt` for all amounts
- Use chain constants from config
- Handle all error cases gracefully
- Show pending states during transactions
